# 面试八股

## c++

### c++程序编译过程

![image-20250902114719136](./c++八股.assets/image-20250902114719136.png)

程序经过预处理、编译、汇编、链接成为可执行程序。

**预处理**

- 对全部的#define进行宏展开。
- 处理全部的条件编译指令，比方#if、#ifdef、#elif、#else、#endif;
- 处理 #include 指令，这个过程是递归的，也就是说被包括的文件可能还包括其它文件;
- 删除全部的注释 // 和 /**/
- 加入行号和文件标识
- 保留全部的 #pragma 编译器指令

**编译**

编译会将源代码由文本形式转换成机器语言，编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件。编译后的.s是ASCII码文件。

**汇编**

- 将汇编代码 .s 翻译成机器指令的 .o 或.obj 目标文件。
- 用于将汇编代码转换成机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。
- 汇编后的.o文件是纯二进制文件。

**链接**

.cpp 文件中的函数引用了另一个 .cpp文件中定义的符号或者调用了某个库文件中的函数。链接是将所有的.o文件和库（动态库、静态库）链接在一起，得到可以运行的可执行文件（Windows的.exe文件或Linux的.out文件）等。链接分为**静态链接**和**动态链接**。

### 静态链接和动态链接

**静态链接**：把目标程序运行时需要调用的函数代码直接链接到了生成的可执行文件中，程序在运行的时候不需要其他额外的库文件，且就算你去静态库把程序执行需要的库删掉也不会影响程序的运行，因为所需要的所有东西已经被链接到了链接阶段生成的可执行文件中。静态库windows以.lib结尾Linux以.a结尾。

**动态链接**：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。程序在执行阶段需要去寻找相应的函数代码，即在程序运行时才会将程序安装模块链接在一起。在Windows下以.dll为后缀，Linux下以.so为后缀。

**两者对比**：静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。

动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。

### 内存布局

从高地址到低地址，一个程序由 内核空间、栈区、堆区、BSS段、数据段（data）、代码区组成。

常说的C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

可执行程序在运行时会多出两个区域：

- 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。栈从高地址向低地址增长。是一块连续的空间。栈一般分配几M大小的内存。
- 堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长。一般可以分配几个G大小的内存。
- 在堆栈之间有一个 共享区（文件映射区）。
- 全局区/静态存储区（.BSS 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，程序中未初始化的全局变量和静态变量存放在.BSS 段中，已初始化的全局变量和静态变量存放在 .data 段中，C++ 中不再区分了。常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。
- 代码区（.text 段）：存放程序执行代码的一块内存区域。只读，不允许修改，但可以执行。编译后的二进制文件存放在这里。代码段的头部还会包含一些只读的常量，如字符串常量字面值（注意：const变量虽然属于常量，但是本质还是变量，不存储于代码段）

<img src="./c++八股.assets/image-20250902113016735.png" alt="image-20250902113016735"/>

### 堆和栈的区别

- 申请方式：栈是系统自动分配，堆是程序员主动申请。
- 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
- 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。
- 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
- 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。

此题总结：

1、申请方式的不同。 栈由系统自动分配，而堆是人为申请开辟;

2、申请大小的不同。 栈获得的空间较小，而堆获得的空间较大;

3、申请效率的不同。 栈由系统自动分配，速度较快，而堆一般速度比较慢;

4、 存储的内容不同。

栈在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

### 左值右值

左值和右值是针对表达式而言的，左值是指表达式执行结束后依然存在的持久对象，右值 是指表达式执行结束后就不再存在的临时对象。

能对表达式取地址的，称为左值；不能取地址的，称为右值。 在实际使用过程中，字面值常量、匿名对象（临时对象）、匿名变量（临时变量），都称为右值。右值又被称为即将被销毁的对象。

```c++
//非const引用尝试绑定
int & r1 = a;
int & r2 = 1;//ERROR 

//const引用尝试绑定
const int & r3 = 1;
const int & r4 = a;
```

非const左值引用只能绑定到左值，不能绑定到右值，也就是非const左值引用只能识别出左值。
const左值引用既可以绑定到左值，也可以绑定到右值，也就是表明const左值引用不能区分左值还是右值。

c++11提出了右值引用，右值引用不能绑定到左值，但可以绑定到右值，也就是右值引用能够识别出右值。右值引用既可以是左值（比如：作为函数的参数、有名字的变量），也可以是右值（函数的返回类型）。

应用场景：有了右值引用后，就可以显示定义移动构造函数和移动赋值函数。传统的拷贝构造和赋值函数需要先申请内存再复制，这样效率较低。引入移动构造和移动赋值函数后就可以省去复制的操作，直接“窃取”源对象的资源指针。

### std::move和std::forward

`std::move`函数可以无条件地把对象转为右值引用，让编译器可以调用移动构造/移动赋值。`std::move` 本身不移动数据，只是个**类型转换**。真正的移动动作发生在调用移动构造/赋值函数时。

```c++
#include <iostream>
#include <string>
#include <utility>

int main() {
    std::string s = "hello";
    std::string s2 = std::move(s); // 调用移动构造
    std::cout << "s after move: " << s << "\n"; // s 处于“有效但未定义”的状态
}

```

`std::forward`保持传入参数的“值类别”（左值/右值），把它原封不动地转发给下一个函数。通常和 **万能引用**（`T&&`，也叫转发引用）一起使用。

```c++
#include <iostream>
#include <utility>

void process(int& x) {
    std::cout << "Lvalue reference\n";
}
void process(int&& x) {
    std::cout << "Rvalue reference\n";
}

template<typename T>
void wrapper(T&& arg) {
    process(std::forward<T>(arg)); // 保持原值类别
}

int main() {
    int a = 10;
    wrapper(a);        // 输出: Lvalue reference
    wrapper(20);       // 输出: Rvalue reference
}
```

### RAII技术

RAII技术其本质是利用对象的生命周期来管理资源（内存资源、文件描述符、文件、锁等），因为当对象的生命周期结束时，会自动调用析构函数。

RAII技术具有以下基本特征：

- 在构造函数中初始化资源，或托管资源；
- 在析构函数中释放资源
- 一般不允许复制或赋值
- 提供若然访问资源的方法

利用栈对象的生命周期管理资源，因为栈对象在离开作用域时候，会执行析构函数。

### 智能指针

`unique_ptr<T>`是一个独占所有权的智能指针：

- 每个unique_ptr拥有一个资源（比如通过 `new` 分配的对象）
- 所有权不能被复制，只能**移动**（使用std::move）
- 当 `unique_ptr` 被销毁时，它会自动 `delete` 所管理的资源

适用于管理需要唯一所有权的资源。

`shared_ptr`就是共享所有权的智能指针，可以进行复制或赋值，但复制或赋值时，并不是真正拷贝对象，而只是将引用计数加1了。**共享所有权**：多个 `shared_ptr` 可以指向同一个对象。

内部通过 **引用计数** 管理资源：

- 创建时计数 +1
- 拷贝构造/赋值时计数 +1
- 析构时计数 -1，若为 0 → 自动释放资源。

适用于多个对象需要共享同一资源的生命周期。

`shared_ptr`会有循环引用的问题，例如：

```c++
struct B; // 前向声明
struct A {
    std::shared_ptr<B> bptr;
};
struct B {
    std::shared_ptr<A> aptr;
};

int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->bptr = b;
    b->aptr = a;
    // ❌ 循环引用：a 和 b 的引用计数永远不为 0，内存泄漏
}
```

解决方法：使用`weak_ptr`，**弱引用**：不会增加 `shared_ptr` 的引用计数。

`weak_ptr`不能直接访问对象，必须先调用 `lock()` 转为 `shared_ptr`。

- 如果资源还在，返回有效 `shared_ptr`。
- 如果资源已释放，返回空指针。

```c++
struct B; 
struct A {
    std::shared_ptr<B> bptr;
};
struct B {
    std::weak_ptr<A> aptr; // 弱引用，不增加引用计数
};
```

### 深拷贝与浅拷贝

- c++默认的拷贝构造函数是浅拷贝

浅拷贝就是对象的数据成员之间的简单赋值，如你设计了一个类而没有提供它的复制构造函数，当用该类的一个对象去给另一个对象赋值时所执行的过程就是浅拷贝。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。

- 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，而不是一个简单的赋值过程，从而也就解决了指针悬挂的问题。

### 匿名函数

匿名函数定义
```c++
[capture list] (parameter list) -> return type
{
   function body;
};
```

- capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。

- return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。

### 面向对象的三大特性

封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。

### 重载、重写、隐藏

重载：是指同一可访问区内被声明几个**具有不同参数列（参数的类型、个数、顺序）的同名函数**，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

重写(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，**只有函数体不同**。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数**必须有 virtual 修饰**。

隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

### 什么是多态

多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。

实现过程：

1. 在类中用 virtual 关键字声明的函数叫做虚函数；
2. 存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；
3. 当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。

### 静态多态和动态多态

静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。

动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。



### 虚函数和纯虚函数

虚函数：被 virtual 关键字修饰的成员函数，就是虚函数。

纯虚函数：

- 纯虚函数在类中声明时，加上 =0；
- 含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；
- 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。

