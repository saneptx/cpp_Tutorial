# C++

## 命名空间

### 创建命名空间

~~~c++
namespace{
    //实体：变量、函数、类等
}
~~~

### 使用命名空间

三种方式：

1. 作用域限定符：`std::cout`
2. using编译指令：`using namespace std`
3. using生名机制：`using std::cout`

命名空间中你可以定义实体可以声明实体，但不能使用实体。使用命名空间中的实体一定是在命名空间之外。命名空间只是用来存放实体的。

## const关键字

### 修饰内置类型*

const修饰的数据类型不能修改。在c语言中通常使用`#define MAX 100`来定义常量。这样并不会对数据类型进行指定，在c++中通常使用`const int MAX =100`来指定一个常量这样就会对常量数据类型进行检查。**const常量必须进行初始化**。`int const MAX = 100`这种写法也是可以的。

~~~c
/*
const常量和宏定义常量的区别：

1.发生实际不同：c语言中的宏定义发生在预处理时，做字符串的替换。const常量是在编译时（const常量本质还是一个变量，只是用const关键字限定之后，赋
予只读属性，使用时依然是以变量的形式去使用）

2.类型和安全检查不同：宏定义没有类型，不做任何类型检查；const常量有具体的类
型，在编译期会执行类型检查。

在使用中，应尽量以const替换宏定义，可以减小犯错误的概率
*/
~~~

### 修饰指针类型*

~~~c++
#include<iostream>
using namespace std;

int main(){
    int number1=3;
    int number2=4;

    int * const p1 = &number1;//指针常量，指向固定的地址可以改变存放地址中的值，不能指向别的地址
    *p1 = 30;
    //p1 = &number2;//不被允许

    const int * p2 = &number2;//常量指针，可以指向任意常量，但不能改变指向常量的值
    //*p2 = 40;//不被允许
    p2 = &number1;
}
~~~

## new/delete表达式

new和delete并不是函数而是表达式。

~~~c++
#include<iostream>
using namespace std;

int main(){
    int *pa = new int();//默认初始化为0
    cout<<*pa<<endl;
    int *pb = new int(3);//初始化为3
    cout<<*pb<<endl;
    int *pc = new int[5]();//默认初始化数组全为0
    for(int i=0;i<5;i++){
        cout<<pc[i]<<" ";
    }
    cout<<endl;
    int *pd = new int[5]{1,2,3,4,5};
    for(int i=0;i<5;i++){
        cout<<pd[i]<<" ";
    }
    cout<<endl;
    delete pa;
    delete pb;
    delete []pc;
    delete []pd;
    pa = nullptr;//安全回收
}
~~~

### new/delete与malloc/free的区别*

~~~c
/*
new delete和malloc free的区别
1. malloc/free是库函数；new/delete是表达式，后两者使用时不是函数的写法；
2. new表达式的返回值是相应类型的指针，malloc返回值是void*；
3. malloc申请的空间不会进行初始化，获取到的空间是有脏数据的，但new表达式申请空间时可以直接初始化；
4. malloc的参数是字节数，new表达式不需要传递字节数，会根据相应类型自动获取空间大小。
*/
~~~

## 引用

引用是一个已定义变量的别名。

#### 引用的使用

~~~c++
int number = 2;
int & ref = number;
~~~

1.  &在这里不再是取地址符号，而是引用符号。
2.   引用的类型需要和其绑定的变量的类型相同（目前这样使用，学习继承后这一条有所不 同）。
3.   声明引用的同时，必须对引用进行初始化，否则编译时报错。
4.  引用一经绑定，无法更改绑定。

由于引用是被限制的指针，所以引用是占据内存的，占据的大小就是一个指针的大小。有 很多的说法，都说引用不会占据存储空间，其只是一个变量的别名，但这种说法并不准 确。引用变量会占据存储空间，存放的是一个地址，但是编译器阻止对它本身的任何访 问，从一而终总是指向初始的目标单元。

#### 引用和指针的区别

~~~c
/*
联系：
1. 引用和指针都有地址的概念，都是用来间接访问变量；
2. 引用的底层还是指针来完成，可以把引用视为一个受限制的指针。
区别：
1. 引用必须初始化，指针可以不初始化；
2. 引用不能修改绑定，但是指针可以修改指向；
3. 在代码层面对引用本身取址取到的是变量的地址，但是对指针取址取到的是指针变量本身的地址
*/
~~~

